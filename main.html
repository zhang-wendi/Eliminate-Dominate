<!DOCTYPE html>
<html>
<head>
    <title>Eliminate & Dominate</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow-x: hidden;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* 上半部分区域 - 图片区 */
        .image-section {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            overflow: hidden;
            position: relative;
            border-bottom: 2px solid rgba(255, 51, 102, 0.3);
        }
        
        .placeholder-image {
            width: 100%;
            height: 100%;
            max-width: 90vmin;
            max-height: 90%;
            background-size: cover;
            background-position: top;
            background-repeat: no-repeat;
            border: 2px solid rgba(255, 51, 102, 0.5);
            position: relative;
            transition: background-image 0.5s ease-in-out;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.2);
        }
        
        /* 下半部分区域 - 游戏区 */
        .game-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 10px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .game-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(255, 51, 102, 0.05) 25%, transparent 25%, transparent 50%, rgba(255, 51, 102, 0.05) 50%, rgba(255, 51, 102, 0.05) 75%, transparent 75%, transparent);
            background-size: 40px 40px;
            pointer-events: none;
        }
        
        .game-container {
            width: 100%;
            max-width: 450px;
            text-align: center;
            position: relative;
            z-index: 1;
        }
        
        h1 {
            font-size: 24px;
            margin: 5px 0 15px;
            color: #ff3366;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 3px;
            background: rgba(255, 51, 102, 0.1);
            padding: 5px;
            border-radius: 8px;
            margin: 0 auto;
            aspect-ratio: 1 / 1;
            width: 100%;
            max-width: 90vmin;
            box-shadow: 0 0 30px rgba(255, 51, 102, 0.2);
            border: 3px solid rgba(255, 51, 102, 0.3);
        }
        
        .cell {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            border-radius: 6px;
            background-color: rgba(0, 0, 0, 0.4);
            overflow: hidden;
            cursor: pointer;
            border: 1px solid rgba(255, 51, 102, 0.2);
            box-shadow: inset 0 0 3px rgba(255, 51, 102, 0.1);
        }
        
        .candy {
            position: absolute;
            top: 8%;
            left: 8%;
            width: 84%;
            height: 84%;
            border-radius: 8px;
            transition: transform 0.2s ease, opacity 0.2s ease;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .selected .candy {
            animation: pulse 0.8s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.8);
            border: 2px solid rgba(255, 51, 102, 0.8);
        }
        
        .score-container {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 51, 102, 0.1);
            color: #ff3366;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.2);
            border: 1px solid rgba(255, 51, 102, 0.3);
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 15px rgba(255, 51, 102, 0.5); }
            50% { transform: scale(1.08); box-shadow: 0 0 25px rgba(255, 51, 102, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 15px rgba(255, 51, 102, 0.5); }
        }
        
        @keyframes softBounce {
            0% { transform: scale(1.2); }
            40% { transform: scale(0.9); }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* 横屏模式处理 */
        @media (orientation: landscape) {
            body {
                flex-direction: row;
            }
            
            .image-section {
                height: 100vh;
                border-bottom: none;
                border-right: 2px solid rgba(255, 51, 102, 0.3);
            }
            
            .game-section {
                height: 100vh;
                justify-content: center;
            }
            
            .placeholder-image {
                height: 90%;
                width: auto;
                max-width: none;
            }
            
            h1 {
                font-size: 20px;
                margin: 0 0 10px;
            }
        }

        /* 游戏结束弹窗样式 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
        }

        .modal-content {
            background: rgba(20, 20, 20, 0.9);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(255, 51, 102, 0.3);
            border: 2px solid rgba(255, 51, 102, 0.5);
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 300px;
        }

        .modal-content h2 {
            color: #ff3366;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }

        #restart-button {
            background: linear-gradient(45deg, #ff3366 0%, #ff0066 100%);
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.3);
        }

        #restart-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(255, 51, 102, 0.5);
        }
    </style>
</head>
<body>
    <!-- 上半部分：图片区 -->
    <div class="image-section">
        <div class="placeholder-image" id="placeholder-image"></div>
    </div>
    
    <!-- 下半部分：游戏区 -->
    <div class="game-section">
        <div class="game-container">
            <!-- <h1>欢乐三消</h1> -->
            <div class="grid" id="game-grid"></div>
            <div class="score-container">Score: <span id="score">0</span></div>
        </div>
    </div>

    <!-- 游戏结束弹窗 -->
    <div class="modal" id="game-over-modal">
        <div class="modal-content">
            <h2>Game Over!</h2>
            <button id="restart-button">Restart</button>
        </div>
    </div>

    <script>
        // 添加角色文件夹配置
        const CONFIG = {
            CHARACTER_FOLDERS: ['blonde_girl', 'red_girl'], // 可用的角色文件夹
            CANDY_IMAGES: [
                'resource/img/block_icon/gag.png',
                'resource/img/block_icon/clamp.png',
                'resource/img/block_icon/handcuff.png',
                'resource/img/block_icon/pet.png',
                'resource/img/block_icon/rope.png',
                'resource/img/block_icon/mask.png'
            ]
        };

        // 玩具配置
        const TOY_CONFIG = {
            PATTERNS: {
                'gag': { intensity: 15, duration: 1000 },
                'handcuff': { intensity: 10, duration: 800 },
                'whip': { intensity: 20, duration: 300 },
                'collar': { intensity: 12, duration: 1500 },
                'blindfold': { intensity: 8, duration: 2000 },
                'clamp': { intensity: 18, duration: 500 }
            },
            MAX_INTENSITY: 20,
            MIN_INTENSITY: 0
        };

        // 玩具控制类
        class ToyController {
            constructor() {
                this.isConnected = false;
                this.init();
            }

            async init() {
                if (window.appGallery && window.appGallery.getToyManager) {
                    try {
                        const toyManager = window.appGallery.getToyManager();
                        this.isConnected = await toyManager.checkConnection();
                        console.log('Toy connection status:', this.isConnected);

                        toyManager.onConnectionChange((connected) => {
                            this.isConnected = connected;
                            console.log('Toy connection changed:', connected);
                        });
                    } catch (error) {
                        console.error('Failed to initialize toy controller:', error);
                    }
                }
            }

            sendCommand(type) {
                if (!this.isConnected) return;
                
                const pattern = TOY_CONFIG.PATTERNS[type];
                if (!pattern) return;

                try {
                    const toyManager = window.appGallery.getToyManager();
                    const command = {
                        action: 'Vibrate',
                        timeSec: pattern.duration / 1000,
                        strength: pattern.intensity
                    };
                    
                    toyManager.sendCommand(command);
                    console.log('Sent toy command:', command);
                } catch (error) {
                    console.error('Failed to send toy command:', error);
                }
            }
        }

        // 游戏状态中添加当前角色文件夹和玩具控制器
        const GAME_STATE = {
            currentCharacterFolder: '', // 当前使用的角色文件夹
            board: [],
            score: 0,
            isAnimating: false,
            selectedCandy: null,
            toyController: null  // 添加玩具控制器引用
        };

        // 游戏配置
        const GRID_SIZE = 8;
        const ANIMATION_DURATION = 300;
        
        // 触摸相关变量
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartCell = null;
        
        // 修改糖果样式
        const candyStyle = document.createElement('style');
        candyStyle.textContent = `
            .candy {
                position: absolute;
                top: 5%;
                left: 5%;
                width: 90%;
                height: 90%;
                border-radius: 10%;
                transition: transform 0.2s ease, opacity 0.2s ease;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
            }
            
            .selected .candy {
                animation: pulse 0.8s ease-in-out infinite;
                box-shadow: 0 0 15px rgba(255,255,255,0.8);
            }
        `;
        document.head.appendChild(candyStyle);
        
        /**
         * 初始化游戏
         */
        async function initGame() {
            console.log('初始化游戏...');
            
            // 初始化玩具控制器
            GAME_STATE.toyController = new ToyController();
            
            // 随机选择一个角色文件夹
            GAME_STATE.currentCharacterFolder = CONFIG.CHARACTER_FOLDERS[
                Math.floor(Math.random() * CONFIG.CHARACTER_FOLDERS.length)
            ];
            console.log('Selected character folder:', GAME_STATE.currentCharacterFolder);
            
            // 设置初始占位图片
            const placeholderImage = document.getElementById('placeholder-image');
            if (placeholderImage) {
                placeholderImage.style.backgroundImage = `url('resource/img/girl_status/${GAME_STATE.currentCharacterFolder}/original.png')`;
            }
            
            const grid = document.getElementById('game-grid');
            grid.innerHTML = '';
            
            // 创建网格
            for (let row = 0; row < GRID_SIZE; row++) {
                GAME_STATE.board[row] = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // 添加点击事件
                    cell.addEventListener('click', handleCellClick);
                    
                    // 添加触摸事件
                    cell.addEventListener('touchstart', handleTouchStart, { passive: false });
                    cell.addEventListener('touchmove', handleTouchMove, { passive: false });
                    cell.addEventListener('touchend', handleTouchEnd);
                    
                    grid.appendChild(cell);
                    GAME_STATE.board[row][col] = cell;
                }
            }
            
            // 填充糖果
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    createCandy(row, col);
                }
            }
            
            // 确保没有匹配的初始棋盘
            while (checkForMatches()) {
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const cell = GAME_STATE.board[row][col];
                        const candy = cell.querySelector('.candy');
                        if (candy) {
                            cell.removeChild(candy);
                            createCandy(row, col);
                        }
                    }
                }
            }
            
            // 重置分数
            GAME_STATE.score = 0;
            updateScore(0);
        }
        
        // 创建糖果
        function createCandy(row, col) {
            const cell = GAME_STATE.board[row][col];
            
            // 创建糖果元素
            const candy = document.createElement('div');
            candy.className = 'candy';
            
            // 随机选择图片
            const imageIndex = Math.floor(Math.random() * CONFIG.CANDY_IMAGES.length);
            candy.dataset.imageIndex = imageIndex; // 存储图片索引用于匹配检查
            candy.style.backgroundImage = `url('${CONFIG.CANDY_IMAGES[imageIndex]}')`;
            
            // 添加到单元格
            cell.appendChild(candy);
            
            return candy;
        }
        
        // 处理单元格点击
        function handleCellClick(e) {
            if (GAME_STATE.isAnimating) return;
            
            const cell = e.currentTarget;
            
            if (GAME_STATE.selectedCandy) {
                // 已有选中的单元格
                
                // 检查是否相邻
                const row1 = parseInt(GAME_STATE.selectedCandy.dataset.row);
                const col1 = parseInt(GAME_STATE.selectedCandy.dataset.col);
                const row2 = parseInt(cell.dataset.row);
                const col2 = parseInt(cell.dataset.col);
                
                const isAdjacent = 
                    (Math.abs(row1 - row2) === 1 && col1 === col2) ||
                    (Math.abs(col1 - col2) === 1 && row1 === row2);
                
                if (isAdjacent) {
                    // 尝试交换
                    trySwap(GAME_STATE.selectedCandy, cell);
                }
                
                // 清除选中状态
                GAME_STATE.selectedCandy.classList.remove('selected');
                GAME_STATE.selectedCandy = null;
            } else {
                // 选中当前单元格
                GAME_STATE.selectedCandy = cell;
                cell.classList.add('selected');
            }
        }
        
        // 处理触摸开始
        function handleTouchStart(e) {
            if (GAME_STATE.isAnimating) return;
            
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartCell = e.currentTarget;
            
            // 防止长按选择文本等默认行为
            e.preventDefault();
        }
        
        // 处理触摸移动
        function handleTouchMove(e) {
            if (!touchStartCell || GAME_STATE.isAnimating) return;
            
            // 防止页面滚动等默认行为
            if (Math.abs(e.touches[0].clientX - touchStartX) > 10 || 
                Math.abs(e.touches[0].clientY - touchStartY) > 10) {
                e.preventDefault();
            }
        }
        
        // 处理触摸结束
        function handleTouchEnd(e) {
            if (!touchStartCell || GAME_STATE.isAnimating) return;
            
            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            
            // 检测滑动方向
            if (Math.abs(deltaX) > 20 || Math.abs(deltaY) > 20) {
                const row = parseInt(touchStartCell.dataset.row);
                const col = parseInt(touchStartCell.dataset.col);
                
                let targetRow = row;
                let targetCol = col;
                
                // 确定主要滑动方向
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // 水平滑动
                    targetCol = col + (deltaX > 0 ? 1 : -1);
                } else {
                    // 垂直滑动
                    targetRow = row + (deltaY > 0 ? 1 : -1);
                }
                
                // 检查目标位置是否有效
                if (targetRow >= 0 && targetRow < GRID_SIZE && 
                    targetCol >= 0 && targetCol < GRID_SIZE) {
                    const targetCell = GAME_STATE.board[targetRow][targetCol];
                    trySwap(touchStartCell, targetCell);
                }
            } else {
                // 如果是轻触，模拟点击
                handleCellClick({ currentTarget: touchStartCell });
            }
            
            touchStartCell = null;
        }
        
        // 尝试交换两个单元格
        function trySwap(cell1, cell2) {
            GAME_STATE.isAnimating = true;
            
            // 保存原始位置信息
            const row1 = parseInt(cell1.dataset.row);
            const col1 = parseInt(cell1.dataset.col);
            const row2 = parseInt(cell2.dataset.row);
            const col2 = parseInt(cell2.dataset.col);
            
            // 获取糖果元素
            const candy1 = cell1.querySelector('.candy');
            const candy2 = cell2.querySelector('.candy');
            
            if (!candy1 || !candy2) {
                GAME_STATE.isAnimating = false;
                return;
            }
            
            // 先临时交换图片来检查是否会形成匹配
            const image1 = candy1.style.backgroundImage;
            const image2 = candy2.style.backgroundImage;
            const index1 = candy1.dataset.imageIndex;
            const index2 = candy2.dataset.imageIndex;
            
            // 检查是否会形成匹配
            candy1.style.backgroundImage = image2;
            candy2.style.backgroundImage = image1;
            candy1.dataset.imageIndex = index2;
            candy2.dataset.imageIndex = index1;
            
            const willMatch = checkForMatches();
            
            // 恢复原始图片
            candy1.style.backgroundImage = image1;
            candy2.style.backgroundImage = image2;
            candy1.dataset.imageIndex = index1;
            candy2.dataset.imageIndex = index2;
            
            // 获取元素在页面中的绝对位置
            const rect1 = candy1.getBoundingClientRect();
            const rect2 = candy2.getBoundingClientRect();
            
            // 创建克隆元素用于动画
            const clone1 = candy1.cloneNode(true);
            const clone2 = candy2.cloneNode(true);
            
            // 设置克隆元素的基础样式
            Object.assign(clone1.style, {
                position: 'fixed',
                top: rect1.top + 'px',
                left: rect1.left + 'px',
                width: rect1.width + 'px',
                height: rect1.height + 'px',
                zIndex: '9999',
                transition: 'none',
                boxShadow: '0 0 10px rgba(255,255,255,0.8)'
            });
            
            Object.assign(clone2.style, {
                position: 'fixed',
                top: rect2.top + 'px',
                left: rect2.left + 'px',
                width: rect2.width + 'px',
                height: rect2.height + 'px',
                zIndex: '9999',
                transition: 'none',
                boxShadow: '0 0 10px rgba(255,255,255,0.8)'
            });
            
            // 将克隆元素添加到body
            document.body.appendChild(clone1);
            document.body.appendChild(clone2);
            
            // 临时隐藏原始糖果
            candy1.style.opacity = '0';
            candy2.style.opacity = '0';
            
            // 延迟一帧后设置过渡效果
            requestAnimationFrame(() => {
                // 设置平滑过渡效果
                clone1.style.transition = `all ${ANIMATION_DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                clone2.style.transition = `all ${ANIMATION_DURATION}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                
                // 小延迟确保过渡效果已应用
                setTimeout(() => {
                    if (willMatch) {
                        // 有效交换 - 先放大一点再移动到对方位置
                        clone1.style.transform = 'scale(1.2)';
                        clone2.style.transform = 'scale(1.2)';
                        
                        setTimeout(() => {
                            clone1.style.top = rect2.top + 'px';
                            clone1.style.left = rect2.left + 'px';
                            clone2.style.top = rect1.top + 'px';
                            clone2.style.left = rect1.left + 'px';
                            
                            setTimeout(() => {
                                clone1.style.transform = 'scale(1)';
                                clone2.style.transform = 'scale(1)';
                            }, ANIMATION_DURATION / 2);
                        }, 100);
                        
                        // 动画结束后
                        setTimeout(() => {
                            // 移除克隆元素
                            document.body.removeChild(clone1);
                            document.body.removeChild(clone2);
                            
                            // 显示并交换原始糖果的图片
                            candy1.style.opacity = '1';
                            candy2.style.opacity = '1';
                            candy1.style.backgroundImage = image2;
                            candy2.style.backgroundImage = image1;
                            candy1.dataset.imageIndex = index2;
                            candy2.dataset.imageIndex = index1;
                            
                            // 执行消除
                            removeMatches();
                        }, ANIMATION_DURATION + 150);
                    } else {
                        // 无效交换 - 使用弹跳效果
                        // 计算路径中点和高度
                        const dx = rect2.left - rect1.left;
                        const dy = rect2.top - rect1.top;
                        const midX1 = rect1.left + dx * 0.45;
                        const midY1 = rect1.top + dy * 0.45;
                        const midX2 = rect2.left - dx * 0.45;
                        const midY2 = rect2.top - dy * 0.45;
                        
                        // 第一段：向前弹跳一部分距离
                        clone1.style.top = midY1 + 'px';
                        clone1.style.left = midX1 + 'px';
                        clone1.style.transform = 'scale(1.1) rotate(10deg)';
                        
                        clone2.style.top = midY2 + 'px';
                        clone2.style.left = midX2 + 'px';
                        clone2.style.transform = 'scale(1.1) rotate(-10deg)';
                        
                        // 第二段：返回原位
                        setTimeout(() => {
                            clone1.style.transition = `all ${ANIMATION_DURATION * 0.7}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                            clone2.style.transition = `all ${ANIMATION_DURATION * 0.7}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                            
                            clone1.style.top = rect1.top + 'px';
                            clone1.style.left = rect1.left + 'px';
                            clone1.style.transform = 'scale(1) rotate(0deg)';
                            
                            clone2.style.top = rect2.top + 'px';
                            clone2.style.left = rect2.left + 'px';
                            clone2.style.transform = 'scale(1) rotate(0deg)';
                        }, ANIMATION_DURATION * 0.4);
                        
                        // 动画完成后
                        setTimeout(() => {
                            // 移除克隆元素
                            document.body.removeChild(clone1);
                            document.body.removeChild(clone2);
                            
                            // 显示原始糖果
                            candy1.style.opacity = '1';
                            candy2.style.opacity = '1';
                            
                            // 恢复可交互状态
                            GAME_STATE.isAnimating = false;
                        }, ANIMATION_DURATION * 1.2);
                    }
                }, 20);
            });
        }
        
        // 查找所有匹配
        function findAllMatches() {
            const matches = new Set();
            
            // 检查水平匹配
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE - 2; col++) {
                    const candy1 = GAME_STATE.board[row][col].querySelector('.candy');
                    const candy2 = GAME_STATE.board[row][col + 1].querySelector('.candy');
                    const candy3 = GAME_STATE.board[row][col + 2].querySelector('.candy');
                    
                    if (candy1 && candy2 && candy3) {
                        const img1 = candy1.dataset.imageIndex;
                        const img2 = candy2.dataset.imageIndex;
                        const img3 = candy3.dataset.imageIndex;
                        
                        if (img1 === img2 && img2 === img3) {
                            matches.add(`${row},${col}`);
                            matches.add(`${row},${col + 1}`);
                            matches.add(`${row},${col + 2}`);
                        }
                    }
                }
            }
            
            // 检查垂直匹配
            for (let col = 0; col < GRID_SIZE; col++) {
                for (let row = 0; row < GRID_SIZE - 2; row++) {
                    const candy1 = GAME_STATE.board[row][col].querySelector('.candy');
                    const candy2 = GAME_STATE.board[row + 1][col].querySelector('.candy');
                    const candy3 = GAME_STATE.board[row + 2][col].querySelector('.candy');
                    
                    if (candy1 && candy2 && candy3) {
                        const img1 = candy1.dataset.imageIndex;
                        const img2 = candy2.dataset.imageIndex;
                        const img3 = candy3.dataset.imageIndex;
                        
                        if (img1 === img2 && img2 === img3) {
                            matches.add(`${row},${col}`);
                            matches.add(`${row + 1},${col}`);
                            matches.add(`${row + 2},${col}`);
                        }
                    }
                }
            }
            
            return matches;
        }
        
        // 检查是否有匹配
        function checkForMatches() {
            const matches = findAllMatches();
            return matches.size > 0;
        }
        
        // 显示游戏结束弹窗
        function showGameOverModal() {
            const modal = document.getElementById('game-over-modal');
            modal.style.display = 'flex'; // 显示弹窗
        }

        // 重新开始游戏的按钮事件
        document.getElementById('restart-button').addEventListener('click', () => {
            const modal = document.getElementById('game-over-modal');
            modal.style.display = 'none'; // 隐藏弹窗
            initGame(); // 重新初始化游戏
        });
        
        /**
         * 更新占位区的图片
         */
        function updatePlaceholderImage(stateImage) {
            const placeholderImage = document.getElementById('placeholder-image');
            const tempImage = new Image();

            // 使用当前选择的角色文件夹
            const imageUrl = `resource/img/girl_status/${GAME_STATE.currentCharacterFolder}/${stateImage}`;
            
            tempImage.src = imageUrl;
            tempImage.onload = () => {
                placeholderImage.style.backgroundImage = `url('${imageUrl}')`;
            };
        }
        
        /**
         * 移除匹配的糖果
         */
        function removeMatches() {
            const matches = findAllMatches();
            
            if (matches.size === 0) {
                GAME_STATE.isAnimating = false;
                return;
            }
            
            // 获取顶部图片区域的中心位置
            const imagePlaceholder = document.querySelector('.placeholder-image');
            const placeholderRect = imagePlaceholder.getBoundingClientRect();
            const targetX = placeholderRect.left + placeholderRect.width / 2;
            const targetY = placeholderRect.top + placeholderRect.height / 2;
            
            // 获取屏幕中心位置
            const screenCenterX = window.innerWidth / 2;
            const screenCenterY = window.innerHeight / 2;
            
            // 记录匹配数量用于分数
            let matchCount = 0;
            let stateImage = 'original.png'; // 默认状态图片
            
            // 转换为数组以便处理
            const matchesArray = Array.from(matches).map(pos => {
                const [row, col] = pos.split(',').map(Number);
                return { row, col };
            });
            
            // 等待所有匹配的糖果执行完动画
            const animationPromises = [];
            
            // 处理每个匹配的糖果
            matchesArray.forEach(({ row, col }) => {
                const cell = GAME_STATE.board[row][col];
                const candy = cell.querySelector('.candy');
                
                if (candy) {
                    matchCount++;
                    
                    // 获取当前糖果的状态图片
                    const imageIndex = candy.dataset.imageIndex;
                    stateImage = `state_${CONFIG.CANDY_IMAGES[imageIndex].split('/').pop().split('.')[0]}.png`;
                    
                    // 创建移动到顶部区域的动画
                    const candyRect = candy.getBoundingClientRect();
                    const clone = candy.cloneNode(true);
                    
                    // 设置克隆元素起始样式
                    Object.assign(clone.style, {
                        position: 'fixed',
                        top: candyRect.top + 'px',
                        left: candyRect.left + 'px',
                        width: candyRect.width + 'px',
                        height: candyRect.height + 'px',
                        zIndex: '9999',
                        transition: 'none',
                        borderRadius: '8px',
                        boxShadow: '0 0 15px rgba(255,255,255,0.8)'
                    });
                    
                    // 添加到body
                    document.body.appendChild(clone);
                    
                    // 创建动画效果
                    const promise = new Promise(resolve => {
                        // 1. 放大并移动到屏幕中心
                        requestAnimationFrame(() => {
                            clone.style.transition = `all 400ms cubic-bezier(0.25, 0.1, 0.25, 1)`; // 加快动画速度
                            
                            Object.assign(clone.style, {
                                top: (screenCenterY - candyRect.height) + 'px',
                                left: (screenCenterX - candyRect.width / 2) + 'px',
                                transform: 'scale(1.5)',
                                borderRadius: '50%',
                                opacity: '0.9'
                            });
                            
                            // 2. 缩小并移动到顶部占位区中心
                            setTimeout(() => {
                                clone.style.transition = `all 300ms cubic-bezier(0.34, 1.56, 0.64, 1)`; // 加快动画速度
                                
                                Object.assign(clone.style, {
                                    top: targetY - candyRect.height / 2 + 'px',
                                    left: targetX - candyRect.width / 2 + 'px',
                                    transform: 'scale(0.5)',
                                    opacity: '0.7'
                                });
                                
                                // 3. 消失效果
                                setTimeout(() => {
                                    clone.style.transition = `all 200ms ease-out`; // 加快动画速度
                                    clone.style.opacity = '0';
                                    clone.style.transform = 'scale(0.1)';
                                    
                                    // 完成后移除克隆元素
                                    setTimeout(() => {
                                        if (document.body.contains(clone)) {
                                            document.body.removeChild(clone);
                                        }
                                        resolve();
                                    }, 200); // 加快动画速度
                                }, 300);
                            }, 400);
                        });
                    });
                    
                    animationPromises.push(promise);
                    
                    // 创建爆炸效果
                    createExplosionEffect(candy);
                    
                    // 移除原始糖果
                    setTimeout(() => {
                        if (cell.contains(candy)) {
                            cell.removeChild(candy);
                        }
                    }, 100);
                }
            });
            
            // 更新分数
            updateScore(matchCount * 10);
            
            // 等待所有动画完成后更新占位区图片
            Promise.all(animationPromises).then(() => {
                // 预加载并更新占位区的图片
                updatePlaceholderImage(stateImage);
                
                // 检查是否还有可能的交换
                setTimeout(() => {
                    if (!checkForPossibleSwaps()) {
                        showGameOverModal(); // 显示游戏结束弹窗
                    } else {
                        dropCandies();
                    }
                }, 100);
            });
        }
        
        // 检查是否还有可能的交换
        function checkForPossibleSwaps() {
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    // 检查当前单元格的右侧和下方
                    if (col < GRID_SIZE - 1) {
                        // 交换右侧的糖果
                        swapCandies(row, col, row, col + 1);
                        if (checkForMatches()) {
                            swapCandies(row, col, row, col + 1); // 还原交换
                            return true;
                        }
                        swapCandies(row, col, row, col + 1); // 还原交换
                    }
                    if (row < GRID_SIZE - 1) {
                        // 交换下方的糖果
                        swapCandies(row, col, row + 1, col);
                        if (checkForMatches()) {
                            swapCandies(row, col, row + 1, col); // 还原交换
                            return true;
                        }
                        swapCandies(row, col, row + 1, col); // 还原交换
                    }
                }
            }
            return false;
        }
        
        // 交换糖果的函数
        function swapCandies(row1, col1, row2, col2) {
            const cell1 = GAME_STATE.board[row1][col1];
            const cell2 = GAME_STATE.board[row2][col2];
            const candy1 = cell1.querySelector('.candy');
            const candy2 = cell2.querySelector('.candy');
            
            if (candy1 && candy2) {
                cell1.removeChild(candy1);
                cell2.removeChild(candy2);
                cell1.appendChild(candy2);
                cell2.appendChild(candy1);
            }
        }
        
        // 创建爆炸效果 (简化版，主要效果通过移动动画实现)
        function createExplosionEffect(candy) {
            const rect = candy.getBoundingClientRect();
            const explosion = document.createElement('div');
            
            // 设置爆炸效果样式
            Object.assign(explosion.style, {
                position: 'fixed',
                top: rect.top + 'px',
                left: rect.left + 'px',
                width: rect.width + 'px',
                height: rect.height + 'px',
                backgroundImage: candy.style.backgroundImage,
                backgroundSize: 'cover',
                backgroundPosition: 'center',
                borderRadius: '50%',
                zIndex: '9990',
                opacity: '0.7',
                boxShadow: '0 0 20px 5px rgba(255,255,255,0.8)',
                animation: 'mini-explosion 0.3s forwards'
            });
            
            // 添加关键帧动画
            if (!document.getElementById('mini-explosion-animation')) {
                const style = document.createElement('style');
                style.id = 'mini-explosion-animation';
                style.textContent = `
                    @keyframes mini-explosion {
                        0% { transform: scale(0.8); opacity: 0.7; }
                        100% { transform: scale(1.3); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // 添加到DOM
            document.body.appendChild(explosion);
            
            // 动画结束后移除
            setTimeout(() => {
                if (document.body.contains(explosion)) {
                    document.body.removeChild(explosion);
                }
            }, 300);
        }
        
        // 糖果下落
        function dropCandies() {
            let moved = false;
            
            // 从底部向上扫描
            for (let col = 0; col < GRID_SIZE; col++) {
                let emptySpaces = 0;
                
                // 从底部向上
                for (let row = GRID_SIZE - 1; row >= 0; row--) {
                    const cell = GAME_STATE.board[row][col];
                    const candy = cell.querySelector('.candy');
                    
                    if (!candy) {
                        // 空位置，增加空位计数
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        // 有糖果且下方有空位，需要下落
                        moved = true;
                        
                        // 目标位置
                        const targetRow = row + emptySpaces;
                        const targetCell = GAME_STATE.board[targetRow][col];
                        
                        // 获取位置信息
                        const candyRect = candy.getBoundingClientRect();
                        const targetRect = targetCell.getBoundingClientRect();
                        
                        // 创建克隆元素用于动画
                        const clone = candy.cloneNode(true);
                        
                        // 设置克隆元素样式
                        Object.assign(clone.style, {
                            position: 'fixed',
                            top: candyRect.top + 'px',
                            left: candyRect.left + 'px',
                            width: candyRect.width + 'px',
                            height: candyRect.height + 'px',
                            zIndex: '9999',
                            transition: 'none',
                            boxShadow: '0 0 10px rgba(255,255,255,0.5)'
                        });
                        
                        // 将克隆元素添加到body
                        document.body.appendChild(clone);
                        
                        // 隐藏原始糖果
                        candy.style.opacity = '0';
                        
                        // 延迟一帧后设置过渡效果
                        requestAnimationFrame(() => {
                            clone.style.transition = `all ${ANIMATION_DURATION * 1.2}ms cubic-bezier(0.2, 0.8, 0.3, 1.2)`;
                            
                            // 小延迟确保过渡效果已应用
                            setTimeout(() => {
                                // 下落动画
                                clone.style.top = targetRect.top + 'px';
                                clone.style.left = targetRect.left + 'px';
                                
                                // 稍微拉长并轻微旋转，增加下落感
                                clone.style.transform = 'scaleY(1.1) rotate(5deg)';
                                
                                // 下落结束时恢复形状
                                setTimeout(() => {
                                    clone.style.transform = 'scale(1) rotate(0)';
                                }, ANIMATION_DURATION * 0.8);
                            }, 20);
                        });
                        
                        // 移动真实糖果
                        setTimeout(() => {
                            // 移除克隆元素
                            if (document.body.contains(clone)) {
                                document.body.removeChild(clone);
                            }
                            
                            // 移动糖果到新位置
                            cell.removeChild(candy);
                            targetCell.appendChild(candy);
                            
                            // 恢复可见
                            candy.style.opacity = '1';
                            
                            // 添加软着陆效果
                            candy.style.animation = 'softBounce 0.3s ease-out';
                            setTimeout(() => {
                                candy.style.animation = '';
                            }, 300);
                        }, ANIMATION_DURATION * 1.2 + 30);
                    }
                }
            }
            
            // 添加新的糖果
            setTimeout(() => {
                fillEmptyCells();
            }, ANIMATION_DURATION * 1.2 + 50);
            
            // 如果没有糖果移动，直接填充
            if (!moved) {
                fillEmptyCells();
            }
        }
        
        // 填充空的单元格
        function fillEmptyCells() {
            let needCheck = false;
            
            // 查找并填充所有空单元格
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const cell = GAME_STATE.board[row][col];
                    
                    if (!cell.querySelector('.candy')) {
                        needCheck = true;
                        
                        // 创建一个新的糖果
                        const newCandy = document.createElement('div');
                        newCandy.className = 'candy';
                        const imageIndex = Math.floor(Math.random() * CONFIG.CANDY_IMAGES.length);
                        newCandy.dataset.imageIndex = imageIndex;
                        newCandy.style.backgroundImage = `url('${CONFIG.CANDY_IMAGES[imageIndex]}')`;
                        
                        // 初始位置设置在单元格上方并隐藏
                        newCandy.style.opacity = '0';
                        newCandy.style.transform = 'translateY(-50px) scale(0.8)';
                        cell.appendChild(newCandy);
                        
                        // 获取最终位置
                        const rect = cell.getBoundingClientRect();
                        
                        // 创建克隆元素用于动画
                        const clone = newCandy.cloneNode(true);
                        
                        // 设置克隆元素样式
                        Object.assign(clone.style, {
                            position: 'fixed',
                            top: (rect.top - 50) + 'px',
                            left: rect.left + 'px',
                            width: rect.width + 'px',
                            height: rect.height + 'px',
                            zIndex: '9999',
                            opacity: '1',
                            transform: 'scale(0.8)',
                            transition: 'none',
                            boxShadow: '0 0 10px rgba(255,255,255,0.5)'
                        });
                        
                        // 将克隆元素添加到body
                        document.body.appendChild(clone);
                        
                        // 延迟一帧后设置过渡效果
                        requestAnimationFrame(() => {
                            clone.style.transition = `all ${ANIMATION_DURATION}ms cubic-bezier(0.2, 0.8, 0.3, 1.2)`;
                            
                            // 小延迟确保过渡效果已应用
                            setTimeout(() => {
                                // 下落动画
                                clone.style.top = rect.top + 'px';
                                clone.style.transform = 'scale(1)';
                            }, 20);
                        });
                        
                        // 动画结束后
                        setTimeout(() => {
                            // 移除克隆元素
                            if (document.body.contains(clone)) {
                                document.body.removeChild(clone);
                            }
                            
                            // 显示原始糖果
                            newCandy.style.opacity = '1';
                            newCandy.style.transform = 'translateY(0) scale(1)';
                            
                            // 添加弹跳效果
                            newCandy.style.animation = 'softBounce 0.3s ease-out';
                            setTimeout(() => {
                                newCandy.style.animation = '';
                            }, 300);
                        }, ANIMATION_DURATION + 30);
                    }
                }
            }
            
            // 检查是否有匹配
            setTimeout(() => {
                if (checkForMatches()) {
                    removeMatches();
                } else {
                    GAME_STATE.isAnimating = false;
                }
            }, ANIMATION_DURATION + 100);
        }
        
        // 更新分数
        function updateScore(points) {
            GAME_STATE.score += points;
            document.getElementById('score').textContent = GAME_STATE.score;
        }
        
        // 启动游戏
        initGame();
        
        // 添加窗口尺寸变化监听，以适应不同屏幕
        window.addEventListener('resize', () => {
            // 可以在这里添加尺寸变化后的处理
        });
        
        // 添加图片加载功能
        document.addEventListener('DOMContentLoaded', () => {
            // 未来可以在这里添加图片加载代码
            // const imageSection = document.querySelector('.image-section');
            // const img = document.createElement('img');
            // img.src = '路径/到/图片.jpg';
            // img.alt = '女性图片';
            // img.style.maxWidth = '100%';
            // img.style.maxHeight = '100%';
            // imageSection.innerHTML = '';
            // imageSection.appendChild(img);
        });
    </script>
</body>
</html>